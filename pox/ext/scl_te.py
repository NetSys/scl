import json
import networkx as nx
import pox.openflow.libopenflow_01 as of
from collections import defaultdict
from pox.core import core
from pox.lib.util import dpid_to_str
from scl_routing import scl_routing, byteify


log = core.getLogger()

# defined by scl.conf.const
TE_VENDOR = 0xfffe
MAX_BANDWIDTH = 1   # Mbps

# if we do not receive the utilization of a pair, assume that partition occurs
# then we set a default utilization of this pair using a penalty value
UTILIZATION_PENALTY = 0.5

def capacity_to_weight(c):
    if c >= 1:
        w = 1
    elif c >= 0.9:
        w = 1
    elif c >= 0.8:
        w = 1.5
    elif c >= 0.7:
        w = 2.5
    elif c >= 0.5:
        w = 5
    elif c >= 0.4:
        w = 10
    elif c >= 0.3:
        w = 30
    elif c >= 0.2:
        w = 100
    elif c >= 0.1:
        w = 300
    else:
        w = 1000
    return w


class scl_te(scl_routing):
    '''
    There are two ways to implement offline TE. One is calculating the fraction
    of traffic in each outport, which can be solved by LP, but require the
    dataplane to support load balance mechanism. The other is calculating the
    link weight, then use OSFP to generate routing.
    We choose the latter method.
    scl_te class inherits some functions of scl_routing that handle link_up and
    link_down events, calculate shortest path routing and update dataplane flow
    tables. The default link weight is 1, the average value.
    scl_te class adds one function to handle the periodical flow stats event
    to adjust link weights. The flow stats event is generated by haking the
    ofp_stats_reply msg with type OFPST_VENDOR.
    '''
    def __init__(self, name):
        super(scl_te, self).__init__(name)
        self.traffic_matrices = defaultdict(
                lambda: defaultdict(lambda: UTILIZATION_PENALTY))
                                    # [host1][host2] --> utilization
        self.edges = {}             # [edge_sw] --> [connected_host_name]
        self.ip2name = {}           # [ip_str] --> sw_name or host_name
        self.get_edges()
        self.get_ip2name()

    def get_edges(self):
        for link in self.topo['links']:
            if link[2][0] == 'h':
                if link[0][0:4] not in self.edges:
                    self.edges[link[0][0:4]] = [link[2][0:4]]
                else:
                    self.edges[link[0][0:4]].append(link[2][0:4])

    def get_ip2name(self):
        for sw_name in self.topo['switches']:
            self.ip2name[self.topo['switches'][sw_name]] = sw_name
        for host_name in self.hosts:
            self.ip2name[self.hosts[host_name]] = host_name

    def graph_add_edge(self, sw1, sw2, w=1, c=1):
        self.graph.add_edge(sw1, sw2, weight=w, capacity=c)

    def _handle_RawStatsReply(self, event):
        log.debug("Switch %s flow_stats upcall.", dpid_to_str(event.dpid))
        if event.ofp.type != of.OFPST_VENDOR or event.ofp.body.vendor != TE_VENDOR:
            return
        log.debug("raw traffic_matrices: %s" % event.ofp.body.data)
        traffic_matrices = byteify(json.loads(event.ofp.body.data))
        # we just need the end to end flow stats
        for sw in traffic_matrices.keys():
            sw_name = self.ip2name[sw.split(':')[0]]
            if sw_name not in self.edges.keys():
                continue
            for nw_src in traffic_matrices[sw]:
                host_name = self.ip2name[nw_src]
                if host_name not in self.edges[sw_name]:
                    continue
                for nw_dst in traffic_matrices[sw][nw_src]:
                        if host_name not in self.traffic_matrices:
                            self.traffic_matrices[host_name] = {}
                        self.traffic_matrices[host_name][self.ip2name[nw_dst]] =\
                                min(1, traffic_matrices[sw][nw_src][nw_dst] /\
                                float(MAX_BANDWIDTH * 1000000))
        if self.traffic_matrices:
            log.debug("received traffic matrices: %s" % json.dumps(self.traffic_matrices))
            self.update_flow_tables(self._calculate_te_route())
            self.traffic_matrices = defaultdict(
                    lambda: defaultdict(lambda: UTILIZATION_PENALTY))

    def _calculate_te_route(self):
        log.debug("calculate te routing...")
        log.debug("edges, num %d: %s", len(self.graph.edges()), json.dumps(self.graph.edges()))
        updates = {'modify': defaultdict(lambda: []), 'delete' : defaultdict(lambda: [])}

        # greedy way to search the local optimal solution
        for a in self.graph:
            for b in self.graph[a]:
                self.graph[a][b]['capacity'] = 1
                self.graph[a][b]['weight'] = 1
        current = 0
        for host1 in self.hosts:
            for host2 in self.hosts:
                if host1 is host2:
                    continue

                # shortest path
                try:
                    paths = list(nx.all_shortest_paths(self.graph, host1, host2, 'weight'))
                except nx.exception.NetworkXNoPath:
                    continue
                path = paths[current % len(paths)]
                current += 1
                log.debug('calculated path: %s' % json.dumps(path))
                path = zip(path, path[1:])

                # adjust the link weight
                # set up a new path would decrease the rest link capacity
                # the new link weight depends on the rest link capacity
                # we have a map function
                for (a, b) in path:
                    self.graph[a][b]['capacity'] = max(
                            0, self.graph[a][b]['capacity'] - self.traffic_matrices[host1][host2])
                    self.graph[a][b]['weight'] = capacity_to_weight(
                            self.graph[a][b]['capacity'])

                # update sw flow table
                for (a, b) in path[1:]:
                    link = self.sw2link[a][b]
                    if self.sw_tables[a][host1][host2] != link:
                        self.sw_tables[a][host1][host2] = link
                        updates['modify'][a].append((host1, host2, link))
                        self.sw_tables_status[a][host1][host2] = 'updated'
                    else:
                        self.sw_tables_status[a][host1][host2] = 'checked'
        for sw in self.sw_tables_status.keys():
            for host1 in self.sw_tables_status[sw].keys():
                for host2 in self.sw_tables_status[sw][host1].keys():
                    if self.sw_tables_status[sw][host1][host2] is not 'updated' and\
                       self.sw_tables_status[sw][host1][host2] is not 'checked':
                        updates['delete'][sw].append((
                            host1, host2, self.sw_tables[sw][host1][host2]))
                        del self.sw_tables[sw][host1][host2]
                        del self.sw_tables_status[sw][host1][host2]
                    else:
                        self.sw_tables_status[sw][host1][host2] = 'to_be_deleted'
        return updates


def launch(name=None):
    if not name:
        log.info('input topology configuration file first')
        return
    core.registerNew(scl_te, name)
